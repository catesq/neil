#ifndef MRMONKINGTON_MCPCHORUS_HPP
#define MRMONKINGTON_MCPCHORUS_HPP

#include "libzzub/ports.h"
#include <stdint.h>
#include <zzub/plugin.h>
#include <zzub/signature.h>

#include "libzzub/cv_connections.h" // Add this line to include the definition of cv_connector
#include <vector>
#include <bit>



const zzub::parameter* para_delay = 0;
const zzub::parameter* para_freq1 = 0;
const zzub::parameter* para_tmod1 = 0;
const zzub::parameter* para_freq2 = 0;
const zzub::parameter* para_tmod2 = 0;



struct Gvals {
    uint16_t delay;
    uint16_t freq1;
    uint16_t tmod1;
    uint16_t freq2;
    uint16_t tmod2;
} __attribute__((__packed__));




const char* zzub_get_signature()
{
    return ZZUB_SIGNATURE;
}



/**
 * a dumb ringbuffer meant for audio rate data used by work_stereo() which always reads from either:
 *    the write index (delay_frame=true) 
 *    the write index + zzub_buffer_size (delay_frame=false)
 * 
 * the buffer always holds exactly 2 * zzub_buffer_size samples 
 * zzub's work_stereo means target plugin reads audio generated by the input plugin on the same or previous frame
 * depending on the relative location of each plugin in the work_order
 * 
 * as each input plugin may be used by plugins working on one of those two frames 
 * this ringbuffer which reads from the two locations is needed
 */
class audiobuffer 
{
    // buffer size
    uint bufsize;

    // mask for the buffer size
    uint bufmask;

    // write index
    uint wi;

    // samples
    std::vector<float> data;

public:
    /**
     * constructor
     */
    audiobuffer()
        : bufsize(2 * zzub_buffer_size), bufmask(bufsize - 1), data(bufsize, 0),  wi(0)
    {
    }


    /* read from the buffer
     *
     * @param dest - destination buffer, must be zzub_buffer_size long
     * @param num - number of samples to read, up to zzub_buffer_size
     * @param delay_frame - read from 
     *     the write index (when delay_frame=true)
     *     the write index + zzub_maxbufsize (when delay_frame=false)
     */
    void read(float* dest, uint num, bool delay_frame)
    {   
        num = num & zzub_buffer_size;

        uint offset = delay_frame ? 0 : (uint) zzub_buffer_size;
        uint ri = wi + offset;
        
        if(ri + num > bufsize) {
            memcpy(dest, &data[ri], (bufsize - ri) * sizeof(float));
            memcpy(dest, &data[0], ((ri + num) & bufmask) * sizeof(float));
        } else {
             memcpy(dest, &data[ri], num * sizeof(float));
        }
    }


    /**
     *  write to the buffer
     * 
     * @param src - source buffer
     * @param num - number of samples to write
     */
    void write(float* src, uint num)
    {
        num = num & zzub_buffer_size;
        uint over = (wi + num) & bufmask;

        if(wi + num > bufsize) {
            memcpy(&data[wi], src, (bufsize - wi) * sizeof(float));
            memcpy(&data[0], src, over * sizeof(float));
        } else {
            memcpy(&data[wi], src, num * sizeof(float));
        }

        wi = over;
    }
};




/**
 * a port for the lfo in/out of the chorus
 */
class lfo_port : public zzub::port {
    audiobuffer buffer;
    const char* port_name;
    const zzub::port_flow direction;


public:
    /**
     * constructor
     * 
     * @param name - name of the port
     * @param direction - input or output port
     */
    lfo_port(
        const char* name,
        zzub::port_flow direction
    )
        : port_name(name)
        , direction(direction)
        , buffer()
    {
    }


    virtual ~lfo_port() {}
    
    /**
     * get the name of the port
     * 
     * @return name of the port
     */
    virtual const char* get_name() override
    {
        return port_name;
    }


    /**
     * get the flow of the port
     * 
     * @return input or output
     */
    virtual zzub::port_flow get_flow() override
    {
        return direction;
    };


    /**
     * get the type of the port
     * 
     * @return zzub::port_type::cv
     */
    virtual zzub::port_type get_type() override
    {
        return zzub::port_type::cv;
    };


    /**
     * get the value of the port
     * 
     * @param buf - buffer to write to
     * @param count - number of samples to write
     * @param use_delay_frame - use previous or current audio frame
     */
    virtual void get_value(float* buf, uint count, bool use_delay_frame) override
    {
        buffer.read(buf, count, use_delay_frame);
    }


    /**
     * set the value of the port
     * 
     * @param buf - buffer to read from
     * @param count - number of samples to read
     */
    virtual void set_value(
        float* buf,
        uint count
    ) override
    {
        buffer.write(buf, count);
    }
};




class MCPChorus : public zzub::plugin {
private:
    zzub::ports_facade* ports;
    Gvals gval;
    unsigned int chunklen = 64;
    unsigned long _size;
    unsigned long _wi;
    unsigned long _gi;
    float _ri[3];
    float _dr[3];
    float _x1, _y1;
    float _x2, _y2;
    float* _line_l;
    float* _line_r;

    float _freq1, _freq2;
    float _delay, _tmod1, _tmod2;

public:
    MCPChorus();
    virtual ~MCPChorus();
    virtual void init(zzub::archive* pi);
    virtual void process_events();
    virtual bool process_stereo(float** pin, float** pout, int numsamples, int mode);
    virtual bool process_offline(float** pin, float** pout, int* numsamples, int* channels, int* samplerate) { return false; }
    virtual const char* describe_value(int param, int value);
    virtual void process_controller_events() { }
    virtual void destroy() { }
    virtual void stop() { }
    virtual void load(zzub::archive* arc) { }
    virtual void save(zzub::archive*) { }
    virtual void attributes_changed() { }
    virtual void command(int) { }
    virtual void set_track_count(int) { }
    virtual void mute_track(int) { }
    virtual bool is_track_muted(int) const { return false; }
    virtual void midi_note(int, int, int) { }
    virtual void event(unsigned int) { }
    virtual const zzub::envelope_info** get_envelope_infos() { return 0; }
    virtual void stop_wave() { }
    virtual int get_wave_envelope_play_position(int) { return -1; }
    virtual const char* describe_param(int) { return 0; }
    virtual bool set_instrument(const char*) { return false; }
    virtual void get_sub_menu(int, zzub::outstream*) { }
    virtual void add_input(const char*, zzub::connection_type) { }
    virtual void delete_input(const char*, zzub::connection_type) { }
    virtual void rename_input(const char*, const char*) { }
    virtual void input(float**, int, float) { }
    virtual void midi_control_change(int, int, int) { }
    virtual bool handle_input(int, int, int) { return false; }
    virtual void process_midi_events(zzub::midi_message* pin, int nummessages) { }
    virtual void get_midi_output_names(zzub::outstream* pout) { }
    virtual void set_stream_source(const char* resource) { }
    virtual const char* get_stream_source() { return 0; }
    virtual void play_pattern(int index) { }
    virtual void configure(const char* key, const char* value) { }
    
    virtual bool connect_ports(zzub::cv_connector& connnector) override;
    virtual void disconnect_ports(zzub::cv_connector& connnector) override;
    virtual zzub::port* get_port(int index) override;
    virtual int get_port_count() override;
    virtual zzub::port* get_port(zzub::port_type, zzub::port_flow, int index) override;
    virtual int get_port_count(zzub::port_type, zzub::port_flow) override;

};




struct MCPChorusInfo : zzub::info {
    MCPChorusInfo()
    {
        this->flags = zzub::plugin_flag_has_audio_input | zzub::plugin_flag_has_audio_output | zzub::plugin_flag_is_effect | zzub::plugin_flag_has_ports;
        this->min_tracks = 0;
        this->max_tracks = 0;
        this->name = "MCP Chorus";
        this->short_name = "MCP Chorus";
        this->author = "MrMonkington";
        this->uri = "@libneil/mrmonkington/effect/mcp_chorus";
        para_delay = &add_global_parameter()
                          .set_word()
                          .set_name("Delay")
                          .set_description("Delay between lines in ms")
                          .set_value_min(0)
                          .set_value_max(300)
                          .set_value_none(65535)
                          .set_value_default(0)
                          .set_state_flag();
        para_freq1 = &add_global_parameter()
                          .set_word()
                          .set_name("Freq 1")
                          .set_description("Mod Frequency 1 in Hz")
                          .set_value_min(0)
                          .set_value_max(10000)
                          .set_value_none(65535)
                          .set_value_default(3)
                          .set_state_flag();
        para_tmod1 = &add_global_parameter()
                          .set_word()
                          .set_name("Mod 1")
                          .set_description("Mod Amp 1 in ms")
                          .set_value_min(0)
                          .set_value_max(100)
                          .set_value_none(65535)
                          .set_value_default(0)
                          .set_state_flag();
        para_freq2 = &add_global_parameter()
                          .set_word()
                          .set_name("Freq 2")
                          .set_description("Mod Frequency 2 in Hz")
                          .set_value_min(0)
                          .set_value_max(30000)
                          .set_value_none(65535)
                          .set_value_default(10)
                          .set_state_flag();
        para_tmod2 = &add_global_parameter()
                          .set_word()
                          .set_name("Mod 2")
                          .set_description("Mod Amp 2 in ms")
                          .set_value_min(0)
                          .set_value_max(300)
                          .set_value_none(65535)
                          .set_value_default(0)
                          .set_state_flag();
    }
    virtual zzub::plugin* create_plugin() const { return new MCPChorus(); }
    virtual bool store_info(zzub::archive* data) const { return false; }
} MachineInfo;




struct MCPChorus_PluginCollection : zzub::plugincollection {

    virtual void initialize(zzub::pluginfactory* factory)
    {
        factory->register_info(&MachineInfo);
    }


    virtual const zzub::info* get_info(const char* uri, zzub::archive* data)
    {
        return 0;
    }


    virtual void destroy()
    {
        delete this;
    }


    virtual const char* get_uri()
    {
        return 0;
    }


    virtual void configure(const char* key, const char* value)
    {
    }
};




zzub::plugincollection* zzub_get_plugincollection()
{
    return new MCPChorus_PluginCollection();
}


#endif // MRMONKINGTON_MCPCHORUS_HPP
