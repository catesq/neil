#encoding: latin-1

# libzzub
# Modular Tracker Library
# Copyright (C) 2006 The libzzub Development Team
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA    02110-1301, USA.

VERSION = "0.3"

import os, sys, platform
import distutils.sysconfig

posix = os.name == 'posix'
linux = sys.platform == 'linux'
x86_64 = platform.machine() == 'x86_64'

Import('main_env')

######################################
#
# init environment and define options
#
######################################

#  describe an error about a missing library
class LibraryNotFound:
    def __init__(self, lib):
        self.lib = lib
    def __str__(self):
        return "error: unable to find dev headers for '%s'" % self.lib

class ExecNotFound:
    def __init__(self, prog):
        self.prog = prog
    def __str__(self):
        return "error: unable to find executable file for '%s'" % self.prog

class SubModuleNotFound:
    def __init__(self, name, url):
        self.name = prog
        self.url = url
    def __str__(self):
        return "error: missing git submodule for %s (%s). try 'git submodule --init --update' in the root dir" % (self.prog, self.url)

class PkgVersionErr:
    def __init__(self, lib, version):
        self.lib = lib
        self.version = version
    def __str__(self):
        return "error: '%s' version needs to be > %s" % (self.lib, self.version)

def tools_converter(value):
    return value.split(',')

def bool_converter(value):
    value = value.lower()
    if value in ('true','enabled','on','yes','1'):
        return True
    elif value in ('false','disabled','off','no','0'):
        return False
    return bool(value)

def audioengine_converter(value):
    value = value.lower()
    if not value in ('portaudio'):
        print("invalid option for AUDIOENGINE:",value)
        sys.exit(1)
    return value

opts = Variables( 'options.conf', ARGUMENTS )
opts.Add("PREFIX", 'Set the install "prefix" ( /path/to/PREFIX )', "/usr/local")
opts.Add("LIBDIR", 'Set the install "libdir", will be concatenated to PREFIX', "/lib")
opts.Add("DESTDIR", 'Set the root directory to install into ( /path/to/DESTDIR )', "")
opts.Add("USE_SIGNATURE", 'Use signature to bond plugins and host (strongly recommended)', True, None, bool_converter)
opts.Add("SNDFILE", 'Support loading of waves via libsndfile', True, None, bool_converter)
opts.Add("DEBUG", "Compile everything in debug mode if true", False, None, bool_converter)
opts.Add("ZZUB_MODULE", "Compile module loading plugin (experimental)", False, None, bool_converter)
opts.Add("ZZUB_STREAM", "Compile stream plugins", True, None, bool_converter)
opts.Add("REVISION", 'Revision number (will be set automatically), default=0', '')
opts.Add("SIGNATURE", 'Host signature (will be set automatically)', '')
opts.Add("CONFIGURED", 'Version for which the build is configured (will be set automatically)', '')
opts.Add("TOOLS", 'Compiler suite to use', 'default', None, tools_converter)
opts.Add("LLVMGCCPATH", 'Path to llvm-gcc', '')
opts.Add("SSE", "Support SSE instructions", False, None, bool_converter)
opts.Add("SSE2", "Support SSE2 instructions", False, None, bool_converter)
opts.Add("LADSPA", "Support LADSPA plugins", False, None, bool_converter)
opts.Add("DSSI", "Support DSSI plugins", False, None, bool_converter)
opts.Add("LV2", "Support LV2 plugins", False, None, bool_converter)
opts.Add("JOBS", "Number of threads to compile with", '2')
opts.Add("PYZZUB", "Support pyzzub", True, None, bool_converter)
opts.Add("GTK3", "Support GTK3 GUIs", False, None, bool_converter)
opts.Add("MAD", "Support libmad encoder", False, None, bool_converter)

env = Environment(ENV = os.environ, options = opts)

def get_revision():
    # its a release build, take the string from a special file
    if os.path.isfile('REVISION'):
        rev = open('REVISION').readline().strip()
        if rev != "" and rev != "exported":
            return rev
    return env['REVISION']

revision = get_revision()
print(revision, file=open('REVISION','w'))
env['REVISION'] = revision

env.SConsignFile()

######################################
#
# build settings
#
######################################

env['SRC_PATH'] = main_env['SRC_PATH']
env['BUILD_PATH'] = main_env['BUILD_PATH']

env.Append(CCFLAGS=['-D__SCONS__'])
env.Append(LIBPATH=['${BUILD_PATH}/lib'])

SetOption('num_jobs', env['JOBS'].replace('-j', ''))

env.Append(CCFLAGS=[ '-DPOSIX', ])
env.Append(LINKFLAGS=[ '-Wl,-rpath=%s' % str(env.Dir('${DESTDIR}${PREFIX}${LIBDIR}')), ])

if os.uname()[0] == 'FreeBSD':
    env.Append(CCFLAGS=[ '-I/usr/local/include' ])
    env.Append(LINKFLAGS=[ '-L/usr/local/lib' ])
    env['LIB_DL'] = env['LIB_RT'] = ''
    env['LIB_COMPAT'] = 'compat'
else:
    env['LIB_DL'] = 'dl'
    env['LIB_RT'] = 'rt'
    env['LIB_COMPAT'] = ''

#if env['COMPILER'] == 'clang':
    #env['CC'] += 'clang'
    #env['CXX'] += 'clang++'
    #gcc = False
    #clang = True
#else:
    #env['CC'] += 'gcc'
    #env['CXX'] += 'g++'
    #gcc = True
    #clang = False

env['CC'] = ' clang'
env['CXX'] = ' clang++'
gcc = True

if gcc:
    #env['CXXFLAGS'] += ['--no-rtti']
    env['CXXFLAGS'] += ['-std=c++17']
    if env['DEBUG'] == False:
        env.Append(CCFLAGS=[
                '-Wall',
                '-Wfatal-errors',
                #'-O1',  O2 O3 break infector and a few others
                '-O2',
                '-fno-strict-aliasing',
                '-ffast-math',
                '-fomit-frame-pointer',
                '-funroll-loops',
                '-DNDEBUG',
        ])
        env.Append(CCFLAGS=ARGUMENTS.get('CCFLAGS'))
    else:
        env.Append(CCFLAGS=[
            '-g',
            '-DDEBUG',
            '-D_DEBUG',
        ])
    if env['SSE2'] == True:
        if not x86_64:
            env.Append(CCFLAGS=[
                '-march=i686',
            ])
        env.Append(CCFLAGS=[
            '-mfpmath=sse',
            '-msse2',
        ])
    elif env['SSE'] == True:
        if not x86_64:
            env.Append(CCFLAGS=[
                '-march=i686',
            ])
        env.Append(CCFLAGS=[
                '-mfpmath=sse',
                '-msse',
        ])

######################################
# 64-bit fixes
######################################

import platform

if x86_64:
    picLibBuilder = Builder(
        action = Action('$ARCOM'),
        emitter = '$LIBEMITTER',
        prefix = '$LIBPREFIX',
        suffix = '$LIBSUFFIX',
        src_suffix = '$OBJSUFFIX',
        src_builder = 'SharedObject'
    )
    env['BUILDERS']['StaticLibrary'] = picLibBuilder
    env['BUILDERS']['Library'] = picLibBuilder
    env.Append(CCFLAGS=[
        '-D__X86_64__'
    ])

######################################
#
# signature
#
######################################

import stat
import socket


env['LIBZZUB_VERSION'] = VERSION
env['SIGNATURE'] = 'libzzub %s r%s %s-%s %s' % (env['LIBZZUB_VERSION'],env['REVISION'],env['CC'],sys.platform,socket.gethostname())

######################################
#
# install paths
#
######################################

try:
    umask = os.umask(0o22)
    #print 'setting umask to 022 (was 0%o)' % umask
except OSError:         # ignore on systems that don't support umask
    pass

import SCons
from SCons.Script.SConscript import SConsEnvironment
SConsEnvironment.Chmod = SCons.Action.ActionFactory(os.chmod,
                lambda dest, mode: 'Chmod: "%s" with 0%o' % (dest, mode))
def ldconfig(dir):
    # execute only if installing into root
    if not str(env['DESTDIR']):
        os.system('ldconfig %s' % dir)
SConsEnvironment.LdConfig = SCons.Action.ActionFactory(ldconfig, lambda dir: 'LdConfig: "%s"' % dir)

def InstallPerm(env, dir, source, perm):
    obj = env.Install(dir, source)
    for i in obj:
        env.AddPostAction(i, env.Chmod(str(i), perm))
    return dir

SConsEnvironment.InstallPerm = InstallPerm

rootpath = "${DESTDIR}${PREFIX}"
binpath = "${DESTDIR}${PREFIX}/bin"
libpath = "${DESTDIR}${PREFIX}${LIBDIR}"
includepath = "${DESTDIR}${PREFIX}/include"
pluginpath = "${DESTDIR}${PREFIX}${LIBDIR}/zzub"
pypath = "%s%s" % (env['DESTDIR'], env['PREFIX'])
pyextpath = distutils.sysconfig.get_python_lib(prefix=pypath)

def install(target, source, perm=None, symlink=False):
    if not perm:
        return env.Install(dir=target, source=source)
    else:
        return env.InstallPerm(dir=target, source=source, perm=perm)

env.Alias(target='install', source=rootpath)
env.Alias(target='install', source=pyextpath)

def install_root(source):
    return install(rootpath, source)

def install_lib(source):
    result = install(libpath, source)
    if posix and (not env['DESTDIR']):
        env.AddPostAction(result, env.LdConfig(libpath))
    return result

def install_python_extension(name,files):
    return install(pyextpath + "/"+name, files)

def install_bin(source):
    return install(binpath, source)

def install_plugin(source):
    return install(pluginpath, source)

def install_plugin_help(name, files):
    return install("${DESTDIR}${PREFIX}/share/doc/zzub/plugins/"+name, files, 0o644)

env['LIBZZUB_SRC_PATH'] = '${SRC_PATH}/libneil/src/libzzub'
env['PLUGINS_SRC_PATH'] = '${SRC_PATH}/libneil/src/plugins'
env['PYZZUB_SRC_PATH'] = '${SRC_PATH}/libneil/src/pyzzub'
env['LANTERNFISH_SRC_PATH'] = '${SRC_PATH}/libneil/src/lanternfish'
env['KISSFFT_SRC_PATH'] = '${SRC_PATH}/libneil/src/kiss_fft'
env['LOGGER_SRC_PATH'] = env['SRC_PATH'] + '/libneil/src/loguru'
env['LOGGER_INCLUDE_PATH'] = env['LOGGER_SRC_PATH']
env['LOGGER_BUILD_PATH'] = env['LOGGER_SRC_PATH'] + '/build/' + ('Debug' if env['DEBUG'] else 'Release')

env['LIB_BUILD_PATH'] = '${BUILD_PATH}/lib:${LOGGER_BUILD_PATH}'
env['BIN_BUILD_PATH'] = '${BUILD_PATH}/bin'

######################################
#
# configure
#
######################################

env.Append(CPPPATH=['${BUILD_PATH}/libneil/include', '${LOGGER_INCLUDE_PATH}'])

######################################
#
# configuration
#
######################################

USE_SNDFILE = env['SNDFILE']

def check_has_executable(conf, name):
    conf.Message("Checking for %s in PATH... " % name)
    for path in os.environ['PATH'].split(os.pathsep):
        fullpath = os.path.join(path,name)
        if os.path.isfile(fullpath):
            conf.Result(fullpath)
            return fullpath
    conf.Result("missing")
    return None

def check_command_is_version(conf, command, version):
    conf.Message("Checking for version of '%s'... " % command)
    ver = os.popen(command).read().strip()
    if ver[:len(version)] == version:
        conf.Result(ver)
        return ver
    conf.Result(ver)
    return None

def check_cpu_flag(conf, flag):
    conf.Message("Checking for '%s' CPU flag... " % flag)
    if linux:
        for line in open('/proc/cpuinfo','r'):
            if ':' in line:
                v = line.index(':')
                key,value = line[:v],line[v+1:]
                key = key.strip()
                value = value.strip()
                if key == 'flags':
                    if flag in value.split(' '):
                        conf.Result("yes")
                        return True
        conf.Result('no')
        return False
    # XXX: add cpu flag check for other platforms
    conf.Result('ERROR: not supported for this platform.')
    return False

def check_pkg_config(context, version):
    context.Message( 'Checking for pkg-config... ' )
    ret = context.TryAction('pkg-config --atleast-pkgconfig-version=%s' % version)[0]
    context.Result( ret )
    return ret

def check_pkg(context, name):
    context.Message( 'Checking for %s... ' % name )
    ret = context.TryAction('pkg-config --exists \'%s\'' % name)[0]
    context.Result( ret )
    return ret

def check_pkg_version(context, name, version):
    context.Message("Checking to see if %s is at least version %s... " % (name, version))
    ret = context.TryAction("pkg-config --atleast-version='%s' '%s'" % (version, name))[0]
    context.Result(ret)
    return ret

def is_cleaning():
    import SCons.Script.Main
    try: return SCons.Script.Main.GetOption('clean')
    except: return SCons.Script.Main.options.clean

if (not is_cleaning()) and ('configure' in COMMAND_LINE_TARGETS):
    import os

    env['CONFIGURED'] = ''
    yesno = {True:'yes', False:'no'}
    conf = Configure(env,
        custom_tests = {
            'HasExecutable' : check_has_executable,
            'CommandIsVersion' : check_command_is_version,
            'CheckCPUFlag' : check_cpu_flag,
            'CheckPKGConfig' : check_pkg_config,
            'CheckPKG' : check_pkg,
            'CheckPKGVersion' : check_pkg_version,
        }
    )

    # make sure all the development libraries are installed

    lib_errors = []

    if not conf.CheckCXXHeader('loguru.cpp'):
        lib_errors += SubModuleNotFound('loguru', 'https://github.com/martinmoene/clue')

    if not conf.CheckCHeader('zlib.h'):
        lib_errors += LibraryNotFound("zlib")

    if not conf.CheckCHeader('sndfile.h'):
        lib_errors += LibraryNotFound("libsndfile")

    if not conf.CheckCHeader('samplerate.h'):
        lib_errors += LibraryNotFound("libsamplerate (libsrc)")

    if not conf.CheckCHeader('fftw3.h'):
        lib_errors += LibraryNotFound("libfftw3")

    if not conf.CheckCHeader('mad.h'):
        lib_errors += LibraryNotFound("libmad")

    if not conf.CheckCHeader('mpg123.h'):
        lib_errors += LibraryNotFound("libmpg123")

    if not conf.CheckCXXHeader('boost/graph/adjacency_list.hpp'):
        lib_errors += LibraryNotFound("libboost-graph")
        
    if not conf.CheckCXXHeader('pugixml.hpp'):
        lib_errors += LibraryNotFound("libpugixml")

    if not conf.CheckCHeader('FLAC/all.h'):
        lib_errors += LibraryNotFound("libflac")
    
    if not conf.CheckCHeader('portaudio.h'):
        lib_errors += LibraryNotFound("portaudio")
        
    if not conf.CheckCHeader('mad.h'):
        env['MAD'] = False
    else:
        env['MAD'] = True
        
    if conf.CheckCHeader('ladspa.h'):
        env['LADSPA'] = True

    if conf.CheckCHeader('dssi.h') and conf.CheckCHeader('lo/lo.h'):
        env['DSSI'] = True
    else:
        env['DSSI'] = False

    # need  about uninstalled lv2 packages 
    missing_lv2 = []
    for pkg, header in (('lilv-0', 'lilv-0/lilv/lilv.h'), ('lv2', 'lv2.h'), ('suil-0', 'suil-0/suil/suil.h')):
        if not conf.CheckCHeader(header):
            missing_lv2 += pkg
    
    if missing_lv2:
        lib_errors += "To build LV2 plugins, install: " + missing_lv2.join()
    else:
        env['LV2'] = True

    if conf.CheckCPUFlag('sse'):
        env['SSE'] = True

    if conf.CheckCPUFlag('sse2'):
        env['SSE'] = False
        env['SSE2'] = True

    if conf.CheckPKG('gtk+-3.0'):
        env['GTK3'] = True
    else:
        env['GTK3'] = False

    if not conf.CheckPKGConfig('0.15.0'):
        lib_errors += PkgVersionErr("pkh-config", "0.15.0")

    if not conf.CheckPKGVersion('portaudio-2.0', '19'):
        lib_errors += PkgVersionErr("portaudio-2.0", "19")

    if not conf.HasExecutable('xmlto'):
        lib_errors += ExecNotFound("xmlto")

    if lib_errors:
        print("Could not build, dependency problems:")
        print("\n".join(lib_errors))
        sys.exit(1)

    print("Finished configuration.")
    print()
    print("=== Using ===".center(50))
    print("GTK3:".rjust(30), yesno[env['GTK3'] == True])
    print("MAD:".rjust(30), yesno[env['MAD'] == True])  
    print("Use SSE CPU extension:".rjust(30),yesno[env['SSE'] == True])
    print("Use SSE2 CPU extension:".rjust(30),yesno[env['SSE2'] == True])
    print()
    print("=== Components ===".center(50))
    print("DSSI:".rjust(30),yesno[env['DSSI'] == True])
    print("LADSPA:".rjust(30),yesno[env['LADSPA'] == True])
    print("LV2:".rjust(30),yesno[env['LV2'] == True])
    print("pyzzub (zubb for Python):".rjust(30),yesno[env['PYZZUB'] == True])
    print()
    print("=== Directories ===".center(50))
    print("Prefix:".rjust(30),env['PREFIX'])
    print("Install into:".rjust(30),env.Dir("${DESTDIR}${PREFIX}"))
    print("Library directory:".rjust(30),env.Dir("${PREFIX}${LIBDIR}"))
    print()
    print("Generate debug info:".rjust(30),env['DEBUG'])

    env = conf.Finish()
    env['CONFIGURED'] = VERSION
    opts.Save('options.conf', env)
    print()
    print("Please check if above settings reflect what you want, then build libzzub using")
    print("\tscons")
    sys.exit(0)

######################################
# save config
######################################
env.Precious('options.conf')
opts.Save('options.conf', env)
Help( opts.GenerateHelpText( env ) )

if (not is_cleaning()) and (env['CONFIGURED'] != VERSION):
    print("libzzub is not configured for version %s yet." % VERSION)
    print("configured for %s" % env['CONFIGURED'])
    print()
    print("Please run 'scons configure' to configure libzzub.")
    sys.exit(1)



######################################
# build loguru logging library 
######################################

if not os.path.exists(env['LOGGER_BUILD_PATH']):
    os.makedirs(env['LOGGER_BUILD_PATH'])

if not os.path.exists(os.path.join(env['LOGGER_BUILD_PATH'], 'libloguru.a')) and not os.path.exists(os.path.join(env['LOGGER_BUILD_PATH'], 'libloguru.lib')):
    prev_dir = os.getcwd()
    build_type = 'Debug' if env['DEBUG'] else 'Release'
    os.chdir(env['LOGGER_BUILD_PATH'])
    env.Execute('cmake -DCMAKE_POSITION_INDEPENDENT_CODE=On -DBUILD_SHARED_LIBS=Off -DCMAKE_BUILD_TYPE=' + build_type + ' ../..')
    env.Execute('cmake --build .')
    os.chdir(prev_dir)

env.Append(LIBPATH=[env['LOGGER_BUILD_PATH']], LIBS=['loguru'])
#######################################
#
# custom builders
#
#######################################


def build_signature(target, source, env):
    print("build signature: %s %s" % (target, source))
    outfilepath = str(target[0])
    optionsconfpath = str(source[0])

    opts = {}
    exec (open(optionsconfpath,"r").read(), {}, opts)

    ofile = open(outfilepath,"w")
    print("// generated by scons, do not touch", file=ofile)
    print("const char ZZUB_SIGNATURE[] = \"%s\";" % opts['SIGNATURE'], file=ofile)
    ofile.close()



builders = dict(
    Signature = Builder(action = build_signature),
    ZIDLCHeader = Builder(action = 'python ${SRC_PATH}/libneil/tools/zidl --c-header $TARGET $SOURCE'),
    ZIDLCDef = Builder(action = 'python ${SRC_PATH}/libneil/tools/zidl --c-def $TARGET $SOURCE'),
    ZIDLPyCtypes = Builder(action = 'python ${SRC_PATH}/libneil/tools/zidl --libversion $LIBZZUB_VERSION --py-ctypes $TARGET $SOURCE'),
)

env['BUILDERS'].update(builders)

#######################################
#
# zidl
#
#######################################
output = []
output.append(env.ZIDLCHeader('${BUILD_PATH}/libneil/include/zzub/zzub.h', '${SRC_PATH}/libneil/include/zzub/zzub.zidl'))
# output.append(env.ZIDLCDef('${BUILD_PATH}/libneil/pyzzub/libzzub.def', '${SRC_PATH}/libneil/include/zzub/zzub.zidl'))
output.append(env.ZIDLPyCtypes('${BUILD_PATH}/libneil/src/pyzzub/zzub/__init__.py', '${SRC_PATH}/libneil/include/zzub/zzub.zidl'))

# make targets dependent on script
env.Depends(output, '${SRC_PATH}/libneil/tools/zidl')

env.ZIDLCHeader('${SRC_PATH}/libneil/include/zzub/zzub.h', '${SRC_PATH}/libneil/include/zzub/zzub.zidl')
#######################################
#
# SConscripts
#
#######################################

Export(
    'install_lib',
    'install_plugin',
    'install_bin',
    'install',
    'install_root',
    'install_plugin_help',
    'install_python_extension',
    'gcc',
    'posix',
    'env',
)

# generate signature
env.Signature(target='include/zzub/signature.h', source='options.conf')
# env.Signature(target='${BUILD_PATH}/libneil/include/zzub/signature.h', source='options.conf')
print("env.signature done")

env.SConscript('${LANTERNFISH_SRC_PATH}/SConscript', variant_dir='${BUILD_PATH}/libneil/src/lanternfish', duplicate=0)
env.SConscript('${KISSFFT_SRC_PATH}/SConscript', variant_dir='${BUILD_PATH}/libneil/src/kiss_fft', duplicate=0)
env.SConscript('${LIBZZUB_SRC_PATH}/SConscript', variant_dir='${BUILD_PATH}/libneil/src/libzzub', duplicate=0)
env.SConscript('${PLUGINS_SRC_PATH}/SConscript', variant_dir='${BUILD_PATH}/libneil/src/plugins', duplicate=0)
env.SConscript('${PYZZUB_SRC_PATH}/SConscript', variant_dir='${BUILD_PATH}/libneil/src/pyzzub', duplicate=0)

#######################################
#
# Rest
#
#######################################

# install zzub plugin and type headers
install(includepath+'/zzub', '${BUILD_PATH}/libneil/include/zzub/plugin.h')
install(includepath+'/zzub', '${BUILD_PATH}/libneil/include/zzub/types.h')
install(includepath+'/zzub', '${BUILD_PATH}/libneil/include/zzub/zzub.h')
install(includepath+'/zzub', '${BUILD_PATH}/libneil/include/zzub/signature.h')
