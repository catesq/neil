# this script turns a flat ctypes module generated by h2ctypes into
# a class interface

from ctypes import *
from StringIO import StringIO
import inspect, sys, os, procwrap

ofile = StringIO()

if len(sys.argv) == 3:
	modulename = sys.argv[1]
	namespace = sys.argv[2]
else:
	modulename = 'pylibzzub'
	namespace = 'zzub'

module = __import__(modulename)

exports = []
structs = []

for objname in dir(module):
	obj = getattr(module, objname)
	if hasattr(obj,'__class__'):
		classname = obj.__class__.__name__
		islocal = inspect.getmodule(obj) == module
		# print objname, classname
		if classname == '_FuncPtr':
			exports.append((objname,obj))
		if (classname == 'StructType') and islocal:
			structs.append((objname,obj))

print '# generated with ctypes2classes.py, do not touch'
print
print 'from ctypes import cast, c_void_p'
print 'from %s import *' % modulename
print

opaquestructs = {}
classnames = {}

for structname, struct in structs:
	if structname.endswith('_t') and (not struct._fields_):
		opaquestructs[struct] = structname
		basestructname = structname[:-len('_t')]
		classname = basestructname.split('_')
		if classname[0] == namespace:
			classname = classname[1:]
		classname = ''.join([x.title() for x in classname])
		classnames[struct] = classname

for structname, struct in structs:
	if structname.endswith('_t') and (not struct._fields_):
		basestructname = structname[:-len('_t')]
		holdername = '_handle'
		classname = classnames[struct]
		print 'class %s(object):' % classname
		print '\t%s = None' % holdername
		print '\t_hash = 0'
		print '\t'		
		factoryfunc = None
		for funcname, func in exports:
			if (func.restype == POINTER(struct)) and (not func.o_args or func.o_args[0][1]._type_ not in opaquestructs): # factory
				factoryfunc = (funcname,func)
				break
		def extract_args(args,decl=True):
			def unwrap(x):				
				if hasattr(x[1],'_type_') and x[1]._type_ in opaquestructs:
					return '%s._handle' % x[0]
				return x[0]
			if decl:
				return [x[0] for x in args]
			else:
				return [unwrap(x) for x in args]
		if factoryfunc:			
			argnames = extract_args(factoryfunc[1].o_args)
			args = ', '.join(['self'] + argnames)
			call = '%s(%s)' % (funcname, ','.join(extract_args(factoryfunc[1].o_args,False)))
			print '\tdef __init__(%s):' % args
			print '\t\tself.%s = %s' % (holdername,call)
			print '\t\tself._hash = cast(self.%s, c_void_p).value' % holdername
		else:
			print '\tdef __init__(self,handle):'
			print '\t\tself._handle = handle'
			print '\t\tself._hash = cast(self._handle, c_void_p).value'
			print
		# hash and comparison functions
		print '\tdef __hash__(self):'
		print '\t\treturn self._hash'
		print
		print '\tdef __eq__(self,other):'
		print '\t\treturn self._hash == hash(other)'
		print
		print '\tdef __ne__(self,other):'
		print '\t\treturn self._hash != hash(other)'
		print
		for funcname, func in exports:			
			if func.argtypes and func.argtypes[0] == POINTER(struct):
				argnames = extract_args(func.o_args)
				callargs = extract_args(func.o_args,False)
				methodname = funcname.split('_')
				for name in basestructname.split('_'):
					if methodname[0] == name:
						methodname = methodname[1:]
				methodname = '_'.join(methodname)
				args = ', '.join(['self'] + argnames[1:])
				call = '%s(%s)' % (funcname, ','.join(['self.'+holdername] + callargs[1:]))
				print '\tdef %s(%s):' % (methodname,args)
				print '\t\tassert self.'+holdername
				if not func.restype:
					print '\t\t' + call
				elif func.restype._type_ in classnames:
					print '\t\treturn %s(%s)' % (classnames[func.restype._type_],call)
				else:
					print '\t\treturn ' + call
				print '\t'
